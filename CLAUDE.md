# はじめに

ユーザーとの対話は日本語で行います。

# 概要

このプロジェクトは"電気椅子ゲーム"というゲームの戦略解析を行うプロジェクトです。
ゲームルールは rule.md に記載します。

# 最終目標

- 全ての到達可能盤面の、プレイヤー 1 目線での評価値、および両プレイヤーの最適混合戦略を求める
- 上の評価値、戦略が各盤面について確認できる web アプリケーションを作成する

# 評価システム

- プレイヤー 1 勝利: +1 点
- プレイヤー 1 敗北: -1 点
- 引き分け: 0 点（将来的に 0.1 点等に変更する可能性あり）
- 進行状態の評価値: 両プレイヤーが最適混合戦略を取った時のプレイヤー 1 目線での期待値

# 手順

- ゲームルールの把握
- ゲームの進行をシミュレートする WEB アプリケーションの作成
  - 各プレイヤーの選択をクリック選択すると、盤面が変動するようなアプリケーション
- 状態のハッシュ化
  - ゲーム進行中に発生する状態を"進行状態"、勝利、敗北、引き分けが確定している盤面を"終了状態"と呼ぶ。
  - 終了状態はハッシュ化しなくてよい
  - ハッシュの形式は、解析時・Web アプリケーションからの取得時も同じ形式を使うと思うので、便利なように考える。ビット列で表現(第 0-3 ビットはターン数、4-15 は椅子の残数)のようにしても 32 程度に収まるだろうから、そういうのでもよい。
  - **実装決定**: 32ビット整数ハッシュを採用（2025年8月1日更新）
    - bit 28-31: ターン数 (4ビット) - 最上位
    - bit 16-27: 椅子残存状態 (12ビットマスク)
    - bit 10-15: プレイヤー1点数 (6ビット)
    - bit 4-9: プレイヤー2点数 (6ビット) 
    - bit 2-3: プレイヤー1電流回数 (2ビット)
    - bit 0-1: プレイヤー2電流回数 (2ビット)
- ある盤面から、プレイヤーの選択により、遷移し得る盤面を導くスクリプト作成
  - ある進行状態からは、別の進行状態か、終了状態に遷移する。
- 到達可能盤面のハッシュ値をすべて求める。
- 到達可能盤面のうち、ターンの大きい盤面から、最適混合戦略および盤面の評価値を求める
  - ターンは必ず 1 増えるため、大きい方から評価値を計算すれば、遷移先の状態が未計算ということは起きない。
  - 最適戦略および評価値は、Web アプリケーションに表示したいため、進行状態ハッシュから呼び出しやすい形式で保存する
  - 解析には時間がかかると思うので、進行状況を管理するシステムを設けるべき。進行状況を読み取り、指定された個数だけ解析し、結果を保存する、というようなメインスクリプトがあり、進行状況を保存するファイルがあり、解析結果を保存するディレクトリやファイルがあり、という感じ。
  - **実装決定**: 以下のシステム構成を採用
    - 進行状況管理: `./analysis-results/progress.json`
    - 結果保存: `./analysis-results/turn-{N}/strategies.json`
    - 最適戦略精度: 小数点以下6桁
    - バッチ処理: 1000盤面単位で解析・保存

# 現在の実装状況

## 完了した機能
- ✅ React + TypeScript Webアプリケーション (Vite使用)
- ✅ ゲームシミュレーション機能（ルール準拠）
- ✅ 32ビット状態ハッシュシステム
- ✅ 状態遷移生成システム
- ✅ 段階的ハッシュ生成（パフォーマンス最適化）
- ✅ 解析進捗管理システム
- ✅ 最適戦略計算エンジン（Fictitious Play）

## 主要バグ修正履歴
1. **状態遷移での配列参照バグ** - `gameLogic.ts:processTurn()`
   - 問題: 浅いコピーにより複数遷移で同じ配列を共有
   - 修正: `chairsRemaining: [...gameState.chairsRemaining]`で深いコピー実装

2. **ゲームルール修正**
   - 勝利条件: `>=40点` → `==40点`
   - 電流回数判定: `>=3回` → `==3回`

3. **UI表示用の役割定義変更** - 2025年8月1日
   - プレイヤー1: 椅子選択側（攻撃）、電気を避ける役割
   - プレイヤー2: 電気仕掛け側（防御）、電気を仕掛ける役割
   - ターン順序: 電気仕掛け側が先、椅子選択側が後
   - 得点・電流対象: 椅子選択側（攻撃側）が得点獲得・電流を受ける

## ファイル構成
詳細は `CODE_STRUCTURE.md` を参照してください。

## 実行方法
```bash
# 開発サーバー起動
npm run dev

# 状態解析実行
npm run analyze

# 解析進捗確認
npm run analyze -- --status

# 設定確認
npm run analyze -- --config
```

## 設定ファイル

プロジェクトルートの `analysis.config.json` で解析設定を管理します：

```json
{
  "evaluation": {
    "player1Win": 1.0,
    "player2Win": -1.0,
    "draw": 0.0
  },
  "analysis": {
    "maxBatchSize": 1000,
    "precisionDigits": 6,
    "saveInterval": 100,
    "outputDirectory": "./analysis-results"
  },
  "performance": {
    "maxCacheSize": 100000,
    "chunkSize": 1000
  }
}
```

主要設定：
- `evaluation.draw`: 引き分け時のプレイヤー1目線での得点（通常0.0、実験的に0.1等に変更可能）
- `analysis.maxBatchSize`: 一度に処理する盤面数
- `analysis.outputDirectory`: 解析結果の保存先

# 重要な注意事項：解析データとの整合性

## 戦略解析スクリプトとWebアプリケーションの整合性
- ✅ **データ整合性**: Webアプリケーションと戦略解析スクリプトは**同一のゲームロジック実装**を使用
- ✅ **実装統一**: `src/utils/gameLogic.ts`を共通で利用し、状態遷移・得点計算・勝利判定が一致
- ✅ **解析データ有効性**: 既存の解析データ（`analysis-results/`）は現在の実装と完全に互換

## UI表示用とロジック用の関数分離
Webアプリケーションでは以下の関数を使い分けています：

### 解析データ互換用（`src/utils/gameLogic.ts`）
- `getCurrentAttacker()` - 解析データと整合性を保つ
- `getCurrentDefender()` - 解析データと整合性を保つ

### UI表示用（`src/utils/gameLogic.ts`）
- `getChairSelector()` - UI上での椅子選択側表示
- `getElectricSetter()` - UI上での電気仕掛け側表示

この設計により、**解析データを再計算することなく**、UIでの表示を変更できています。
